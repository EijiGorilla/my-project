import{P as v,fV as K,o5 as Q,o6 as V,lQ as A,lU as B,o7 as D,o8 as F,aK as H,g1 as J,v as X,_ as w,d as T,dj as Z,e as Y,o9 as i,oa as ee,d_ as te,i6 as E,cR as I,b2 as ae,gZ as se,my as ne,ob as G,oc as re,od as oe,bT as ie,oe as le,as as q,of as ce}from"./index-DWB-5FUE.js";import{c as ue}from"./distanceOperator-BsZ_4jpZ.js";var j;let m=j=class extends v{constructor(n){super(n),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const n=this.center,t=this.numberOfPoints;if(this.hasZ=n?.hasZ??!1,this.rings.length!==0||!n)return;const o=K(this.radius,this.radiusUnit,"meters"),s=n.spatialReference;let r,e="geographic";if(s.isWebMercator?e="webMercator":((s.wkid&&Q[s.wkid])!=null||(s.wkt2||s.wkt)&&V(s.wkt2||s.wkt))&&(e="projected"),this.geodesic){let a;switch(e){case"webMercator":a=A(n);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":a=n}r=this._createGeodesicCircle(a,o,t),e==="webMercator"&&(r=B(r))}else{let a;e==="webMercator"||e==="projected"?a=o/D(n.spatialReference):e==="geographic"&&(a=F(o,"meters",H(n.spatialReference).radius)),r=this._createPlanarCircle(n,a,t)}this.spatialReference=r.spatialReference,this.addRing(r.rings[0])}clone(){const{center:n,numberOfPoints:t,radius:o,radiusUnit:s,geodesic:r}=this;return new j({center:n?.clone(),numberOfPoints:t,radius:o,radiusUnit:s,geodesic:r})}_createGeodesicCircle(n,t,o){const s=[],r=[n.x,n.y];for(let e=0;e<360;e+=360/o){const a=this.hasZ?[0,0,n.z??0]:[0,0];J(a,r,e,t,X.WGS84),s.push(a)}return s.push(s[0]),new v({rings:[s]})}_createPlanarCircle(n,t,o){const s=[],r=2*Math.PI/o;for(let e=0;e<o;++e){const a=r*e,c=[n.x+Math.cos(-a)*t,n.y+Math.sin(-a)*t];this.hasZ&&c.push(n.z??0),s.push(c)}return s.push(s[0]),new v({spatialReference:n.spatialReference,rings:[s]})}};w([T({type:Z})],m.prototype,"center",void 0),w([T()],m.prototype,"geodesic",void 0),w([T()],m.prototype,"numberOfPoints",void 0),w([T()],m.prototype,"radius",void 0),w([T()],m.prototype,"radiusUnit",void 0),m=j=w([Y("esri.geometry.Circle")],m);const pe=m;function g(n,t){const o=new Z({x:n[0],y:n[1],spatialReference:t});return n.length>2&&(o.z=n[2]),o}function fe(n,t){return new le({points:n,spatialReference:t})}function xe(n,t,o){const s=new ie({paths:n,spatialReference:t});return o&&G(s),s}function _(n,t,o,s=!0){const r=ae(n);r.forEach(a=>{const c=a[0],l=a[a.length-1];se(c,l)&&a.length!==1||a.push(a[0])});let e=new v({rings:r,spatialReference:t});return e.rings.forEach(a=>{ne(a)||a.reverse()}),o&&G(e),s&&!re(e)&&E(t)&&(e=oe(e)||e),e}function de(n,t,o){const s=t.mapToLocalMultiple(n),r=[],e={x:s[0].x,y:s[0].y},a={x:s[1].x,y:s[1].y},c=Math.round(a.x-e.x),l=Math.round(a.y-e.y),h=Math.max(Math.abs(c),Math.abs(l));if(o){const u={x:e.x+h,y:e.y+h},f={x:e.x-h,y:e.y-h};r.push(i(u.x,f.y),i(f.x,f.y),i(f.x,u.y),i(u.x,u.y))}else{const u={x:c>0?e.x+h:e.x-h,y:l>0?e.y+h:e.y-h};r.push(i(e.x,e.y),i(u.x,e.y),i(u.x,u.y),i(e.x,u.y))}return N(_([r.map(u=>t.localToMap(u)).filter(I)],t.spatialReference,t.doUnnormalization,!0),r,t)}function Me(n,t,o){let s=t.mapToLocalMultiple(n);if(s.length===1){const l=s[0];s=[i(l.x-48,l.y+48),i(l.x+48,l.y-48),i(l.x+48,l.y-48),i(l.x-48,l.y+48)]}const r=[],e={x:s[0].x,y:s[0].y},a={x:s[1].x,y:s[1].y};if(o){const c=Math.round(a.x-e.x),l=Math.round(a.y-e.y);r.push(i(e.x-c,e.y-l),i(a.x,e.y-l),i(a.x,a.y),i(e.x-c,a.y))}else r.push(i(e.x,e.y),i(a.x,e.y),i(a.x,a.y),i(e.x,a.y));return N(_([r.map(c=>t.localToMap(c)).filter(I)],t.spatialReference,t.doUnnormalization,!0),r,t)}function N(n,t,o){const s=z(t[3],t[2],o),r=z(t[1],t[2],o),e=z(t[0],t[1],o),a=z(t[0],t[3],o);return{geometry:n,midpoints:s!=null&&r!=null&&e!=null&&a!=null?{top:s,right:r,bottom:e,left:a}:null}}function z(n,t,o){$[0]=n.x,$[1]=n.y,$[2]=0,P[0]=t.x,P[1]=t.y,P[2]=0,ce($,$,P,.5),k.x=$[0],k.y=P[1],k.z=P[2];const s=o.localToMap(k);return s!=null?g(s,o.spatialReference):null}const k=i(0,0,0),$=q(),P=q();function me(n,t,o,s){const r=t.mapToLocalMultiple(n);let e=null,a=null;if(o)e=r[0],a=r[1];else{const p=r[0],y=r[1],b=Math.round(y.x-p.x),R=Math.round(y.y-p.y),x=Math.max(Math.abs(b),Math.abs(R));e=i(b>0?p.x+x/2:p.x-x/2,R>0?p.y+x/2:p.y-x/2),a=i(Math.abs(b)>Math.abs(R)?e.x-x/2:e.x,Math.abs(b)>Math.abs(R)?e.y:e.y-x/2)}const c=t.localToMap(e),l=t.localToMap(a);if(c==null||l==null)return null;t.doUnnormalization&&ee([[c,l]],t.spatialReference);const h=g(c,t.spatialReference),u=g(l,t.spatialReference),f=te(t.spatialReference);let d=0;if(E(t.spatialReference))d=f*ue(h,u);else{const p=e.x-a.x,y=e.y-a.y;d=f*Math.sqrt(p*p+y*y)*1}const U=new pe({center:h,radius:d,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:_(U.rings,U.spatialReference,!1),center:h,edge:u}}function ge(n,t,o){const s=t.mapToLocalMultiple(n),r=s[0],e=s[1],a=Math.round(e.x-r.x),c=Math.round(e.y-r.y),l=i(o?r.x:r.x+a/2,o?r.y:r.y+c/2),h=o?a:a/2,u=o?c:c/2,f=60,d=[],U=2*Math.PI/f;function p(M){const S=Math.cos(M),W=Math.sin(M);return i(h*S+l.x,u*W+l.y)}for(let M=0;M<f;M++)d.push(p(M*U));d.push(d[0]);const{spatialReference:y,doUnnormalization:b}=t,R=_([d.map(M=>t.localToMap(M)).filter(I)],y,b,!1),x=t.localToMap(p(Math.PI/2)),C=t.localToMap(p(0)),L=t.localToMap(p(-Math.PI/2)),O=t.localToMap(p(Math.PI));return{geometry:R,midpoints:x!=null&&C!=null&&L!=null&&O!=null?{top:g(x,y),right:g(C,y),bottom:g(L,y),left:g(O,y)}:null}}export{fe as R,_ as T,Me as U,de as b,xe as j,me as k,ge as v};
