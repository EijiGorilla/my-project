import{jq as V,jp as w,Ju as q,jg as F,fi as O,jj as D,fu as f,iS as K,ky as x,Jv as b,Jw as k,Jx as I,Jy as z,Jz as N,kz as J,JA as Z,lC as H,lD as L,JB as Q,lB as W,lE as X,cR as Y}from"./index-DWB-5FUE.js";var U=Z;function g(l,e){return{m_geometry:l,m_side:e}}function tt(l,e,n,t,u,o){if(e.isEmpty()){const a=g(e,0);return void u.push(a)}if(n.isEmpty()){const a=g(e,0);return void u.push(a)}const s=[],r=new x;{const a=r.createGeometryUserIndex(),C=r.addGeometry(e),j=r.addGeometry(n),d=new z(o);let p=0,i=null;if(r.hasCurves()){i=new U;const h=r.getEnvelope2D(o);p=b(t.total());const _=k(t.total(),h);I(r,_,t.total(),12e3,i,null,o)}r.dbgVerifyCurves(),d.setEditShapeCrackAndCluster(r,t),d.cut(l,a,C,j,s);for(const h of s){i!==null&&i.stitchCurves(r,h,p,!1);const _=g(r.getGeometry(h),N(r.getGeometryUserIndex(h,a)));u.push(_)}i!==null&&i.clearStitcher(r)}}function et(l,e,n,t,u,o){if(e.isEmpty()){const a=g(e,0);return void u.push(a)}if(n.isEmpty()){const a=g(e,0);return void u.push(a)}const s=[],r=new x;{const a=r.createGeometryUserIndex(),C=r.addGeometry(e),j=r.addGeometry(n),d=new z(o);let p=0,i=null;if(r.hasCurves()){i=new U;const m=r.getEnvelope2D(o);p=b(t.total());const y=k(t.total(),m);I(r,y,t.total(),12e3,i,null,o)}r.dbgVerifyCurves(),d.setEditShapeCrackAndCluster(r,t),d.cut(!1,a,C,j,s),i!==null&&i.stitchCurves(r,J,p,!0);let h=r.getGeometry(C);const _=new f,E=new f,v=[];for(let m=0;m<s.length;m++){let y=null;{const c=new x,P=c.addGeometry(h),S=c.addGeometry(r.getGeometry(s[m]));if(c.hasCurves()){const A=c.getEnvelope2D(o);p=b(t.total());const R=k(t.total(),A);I(c,R,t.total(),12e3,i,null,o)}d.setEditShapeCrackAndCluster(c,t);const T=d.intersection(P,S);if(i!==null&&i.stitchCurves(c,J,p,!0),y=c.getGeometry(T),y.isEmpty())continue;const G=r.getGeometryUserIndex(s[m],a);G===2?_.add(y,!1):G===1?E.add(y,!1):v.push(y)}{const c=new x,P=c.addGeometry(h),S=c.addGeometry(r.getGeometry(s[m]));if(c.hasCurves()){const G=c.getEnvelope2D(o);p=b(t.total());const A=k(t.total(),G);I(c,A,t.total(),12e3,i,null,o)}d.setEditShapeCrackAndCluster(c,t);const T=d.difference(P,S);i!==null&&i.stitchCurves(c,J,p,!0),h=c.getGeometry(T)}}if(!h.isEmpty()&&s.length>0&&v.push(h),_.isEmpty()&&E.isEmpty())return;if(!_.isEmpty()){const m=g(_,1);u.push(m)}if(!E.isEmpty()){const m=g(E,2);u.push(m)}for(let m=0,y=v.length;m<y;++m){const c=g(v[m],3);u.push(c)}}}class st{getOperatorType(){return 10005}accelerateGeometry(e,n,t){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}execute(e,n,t,u,o){return new rt(e,n,t,u,o)}}class rt extends V{constructor(e,n,t,u,o){super(),this.m_cutIndex=-1,this.m_cuts=[],this.m_progressTracker=o,this.m_cuttee=n.clone(),this.m_cutter=new w({copy:t}),this.m_bConsiderTouch=e;const s=q(n,t);this.m_tolerance=F(u,s,!0)}next(){return this.m_cutIndex===-1&&this.generateCuts(),++this.m_cutIndex<this.m_cuts.length?this.m_cuts[this.m_cutIndex]:null}getGeometryID(){return this.m_cutIndex}tock(){return!0}getRank(){return 1}generateCuts(){switch(this.m_cuttee.getGeometryType()){case O.enumPolyline:this.generatePolylineCuts();break;case O.enumPolygon:this.generatePolygonCuts()}}generatePolylineCuts(){const e=new w,n=new w,t=new w;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(n);const u=[];tt(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,u,this.m_progressTracker);for(let o=0;o<u.length;o++){const s=u[o];s.m_side===1?e.add(s.m_geometry,!1):s.m_side===2||s.m_side===4?n.add(s.m_geometry,!1):s.m_side===3?this.m_cuts.push(s.m_geometry):s.m_side===0?t.add(s.m_geometry,!1):D("")}t.isEmpty()||e.isEmpty()&&n.isEmpty()&&!(this.m_cuts.length>=3)||this.m_cuts.push(t),e.isEmpty()&&n.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}generatePolygonCuts(){const e=new f,n=new f,t=new f;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(n);const u=[];et(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,u,this.m_progressTracker);for(let o=0;o<u.length;o++){const s=u[o];s.m_side===1?e.add(s.m_geometry,!1):s.m_side===2?n.add(s.m_geometry,!1):s.m_side===3?this.m_cuts.push(s.m_geometry):s.m_side===0?t.add(s.m_geometry,!1):D("")}K(t.isEmpty()||u.length===1),e.isEmpty()&&n.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}}const $=new st;function nt(l,e,n){const t=$.execute(!0,l,e,n,null);return Array.from(t)}function ot(){return $.supportsCurves()}function B(l,e){const n=H(l);return nt(W(l),Q(e),L(n)).map(t=>X(t,n)).filter(Y)}const M=ot(),ct=Object.freeze(Object.defineProperty({__proto__:null,execute:B,supportsCurves:M},Symbol.toStringTag,{value:"Module"})),it=Object.freeze(Object.defineProperty({__proto__:null,execute:B,supportsCurves:M},Symbol.toStringTag,{value:"Module"}));export{it as c,ct as i};
