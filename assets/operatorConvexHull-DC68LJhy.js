import{iN as a,fi as i,jo as y,kw as p,kF as P,ak as h,jq as G,iO as d,kG as x,ff as s,jp as m,fg as w,fu as M,kH as _,iS as v,kI as D,kJ as q,kK as k}from"./index-DWB-5FUE.js";class E{getOperatorType(){return 10102}supportsCurves(){return!0}accelerateGeometry(u,o,e){return!1}canAccelerateGeometry(u){return!1}executeMany(u,o,e){return new X(o,u,e)}execute(u,o){return l(u)}isConvex(u,o){if(a(u),u.isEmpty())return!0;const e=u.getGeometryType();if(e===i.enumPoint)return!0;if(e===i.enumEnvelope){const r=u;return r.getXMin()!==r.getXMax()&&r.getYMin()!==r.getYMax()}if(y(e)){const r=u;return!r.getStartXY().equals(r.getEndXY())}if(e===i.enumMultiPoint)return u.getPointCount()===1;if(e===i.enumPolyline){const r=u;return r.getPathCount()===1&&r.getPointCount()===2&&!r.getXY(0).equals(r.getXY(1))}if(e===i.enumGeometryCollection){const r=u;return r.getGeometryCount()===1&&this.isConvex(r.getGeometry(0),o)}const t=u;return!(t.getPathCount()!==1||t.getPointCount()<3)&&p(t,0)}constructOrientedMinimumBoundingBox(u,o,e,t,r){P(u,o,e,t,r)}}class X extends G{constructor(u,o,e){super(),o||d(""),this.m_progressTracker=e,this.m_index=-1,this.m_bMerge=u,this.m_bDone=!1,this.m_inputGeometryCursor=o}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge){if(!this.m_bDone){const u=C(this.m_inputGeometryCursor);return this.m_bDone=!0,u}return null}if(!this.m_bDone){const u=this.m_inputGeometryCursor.next();if(u!==null)return x(u),a(u),this.m_index=this.m_inputGeometryCursor.getGeometryID(),l(u);this.m_bDone=!0}return null}}function C(n,u){const o=new k;let e;for(;e=n.next();)x(e),a(e),o.addGeometry(e);return o.getBoundingGeometry()}function l(n,u){if(a(n),n.isEmpty())return n.createInstance();const o=n.getGeometryType();if(y(o)){const e=n;if(e.isDegenerate(0)){const t=new s;return e.queryStart(t),t}if(e.getGeometryType()===i.enumLine){const t=new s,r=new m({vd:n.getDescription()});return e.queryStart(t),r.startPathPoint(t),e.queryEnd(t),r.lineToPoint(t),r}{const t=new m({vd:n.getDescription()});return t.addSegment(e,!0),l(t)}}if(o===i.enumEnvelope){const e=n,t=new w;if(e.queryEnvelope(t),t.xmin===t.xmax&&t.ymin===t.ymax){const r=new s;return e.queryCornerByVal(0,r),r}if(t.xmin===t.xmax||t.ymin===t.ymax){const r=new s,g=new m({vd:n.getDescription()});return e.queryCornerByVal(0,r),g.startPathPoint(r),e.queryCornerByVal(1,r),g.lineToPoint(r),g}{const r=new M({vd:n.getDescription()});return r.addEnvelope(e,!1),r}}if(o===i.enumGeometryCollection)return C(_(n,-1));if(f(n)){if(o===i.enumMultiPoint){const e=n,t=new s;return e.getPointByVal(0,t),t}return n}return v(D(o)),q(n)}function f(n,u){if(a(n),n.isEmpty())return!0;const o=n.getGeometryType();if(o===i.enumPoint)return!0;if(o===i.enumEnvelope){const t=n;return t.getXMin()!==t.getXMax()&&t.getYMin()!==t.getYMax()}if(y(o)){const t=n;if(t.isDegenerate(0))return!1;if(o===i.enumLine)return!0;const r=new m;return r.addSegment(t,!0),f(r)}if(o===i.enumMultiPoint)return n.getPointCount()===1;if(o===i.enumPolyline){const t=n;return!t.hasNonLinearSegments()&&t.getPathCount()===1&&t.getPointCount()===2&&!t.getXY(0).equals(t.getXY(1))}if(o===i.enumGeometryCollection){const t=n;return t.getGeometryCount()===1&&f(t.getGeometry(0))}const e=n;return!(e.getPathCount()!==1||e.getPointCount()<3)&&p(e,0)}const c=new E;function T(n){return c.execute(n,null)}function b(n,u){const o=c.executeMany(new h(n),u,null);return Array.from(o)}function B(n){return c.isConvex(n,null)}function S(){return c.supportsCurves()}export{B as D,b as _,S as q,T as w};
