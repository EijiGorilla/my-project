import{le as k,bo as me,hh as U,e1 as q,pB as ve,d6 as pe,pC as ge,fL as Q,ej as re,er as le,es as ce,pD as _e,pE as we,f0 as Me}from"./index-glGZSouV.js";import{G as be,H as $e,I as Oe,J as ye,K as Te,L as Ve,M as Re,e as ze,N as Le}from"./OutputColorHighlightOID.glsl-BOzJFLXV.js";import{s as Pe,o as Ce}from"./BufferView-B_Q5ApSP.js";import{t as z}from"./glsl-B5bJgrnA.js";let rt=class extends be{constructor(e){super(e),this._numLoading=0,this._disposed=!1,this._textures=e.textures,this.updateTexture(e.textureId),this._acquire(e.normalTextureId,s=>this._textureNormal=s),this._acquire(e.emissiveTextureId,s=>this._textureEmissive=s),this._acquire(e.occlusionTextureId,s=>this._textureOcclusion=s),this._acquire(e.metallicRoughnessTextureId,s=>this._textureMetallicRoughness=s)}dispose(){super.dispose(),this._texture=k(this._texture),this._textureNormal=k(this._textureNormal),this._textureEmissive=k(this._textureEmissive),this._textureOcclusion=k(this._textureOcclusion),this._textureMetallicRoughness=k(this._textureMetallicRoughness),this._disposed=!0}ensureResources(e){return this._numLoading===0?2:1}get textureBindParameters(){return new Fe(this._texture?.glTexture??null,this._textureNormal?.glTexture??null,this._textureEmissive?.glTexture??null,this._textureOcclusion?.glTexture??null,this._textureMetallicRoughness?.glTexture??null)}updateTexture(e){this._texture!=null&&e===this._texture.id||(this._texture=k(this._texture),this._acquire(e,s=>this._texture=s))}_acquire(e,s){if(e==null)return void s(null);const o=this._textures.acquire(e);if(me(o))return++this._numLoading,void o.then(r=>{if(this._disposed)return k(r),void s(null);s(r)}).finally(()=>--this._numLoading);s(o)}};class qe extends $e{constructor(e=null){super(),this.textureEmissive=e}}let Fe=class extends qe{constructor(e,s,o,r,i,c,l){super(o),this.texture=e,this.textureNormal=s,this.textureOcclusion=r,this.textureMetallicRoughness=i,this.scale=c,this.normalTextureTransformMatrix=l}},Ne=class{constructor(e=0,s=!1,o=!0){this.tolerance=e,this.isVerticalRay=s,this.normalRequired=o}};const Y=pe();function at(t,e,s,o,r,i){if(!t.visible)return;const c=U(xe,o,s),l=(u,n,h)=>i(u,h,n),{tolerance:a}=e,d=new Ne(a,!1,e.options.normalRequired);if(t.boundingInfo)Pe(t.type===0),ue(t.boundingInfo,s,c,a,r,d,l);else{const u=t.positionAttribute,n=u.indices;de(s,c,0,n.length/3,n,u.data,u.stride,r,d,l)}}const Se=q();function ue(t,e,s,o,r,i,c){if(t==null)return;const l=He(s,Se);if(ve(Y,t.bbMin),ge(Y,t.bbMax),r?.applyToAabb(Y),Ue(Y,e,l,o)){const{primitiveIndices:a,position:d}=t,u=a?a.length:d.indices.length/3;if(u>Ge){const n=t.getChildren();if(n!==void 0){for(const h of n)ue(h,e,s,o,r,i,c);return}}je(e,s,0,u,d.indices,d.data,d.stride,a,r,i,c)}}const K=q();function lt(t,e,s,o,r,i,c,l,a){const{data:d,stride:u}=i;de(t,U(xe,e,t),s,o,r,d,u,c,l,a)}function ct(t,e,s,o){if(!s.visible)return;const r=(a,d,u)=>o(a,u,d),{boundingInfo:i}=s;if(i){const{bbMin:a,bbMax:d}=i;if(t<a[0]||t>d[0]||e<a[1]||e>d[1])return}const c=s.positionAttribute,l=c.indices;Ie(t,e,0,l.length/3,l,c,r)}function Ie(t,e,s,o,r,i,c){const{data:l,stride:a}=i;for(let d=s;d<o;++d){const u=3*d,n=a*r[u],h=a*r[u+1],R=a*r[u+2],v=l[n+0]-t,p=l[n+1]-e,f=l[h+0]-t,W=l[h+1]-e,x=l[R+0]-t,$=l[R+1]-e,O=x*W-$*f,y=v*$-p*x,g=f*p-W*v;(O<0||y<0||g<0)&&(O>0||y>0||g>0)||c(0,d,null)}}function De(t,e,s,o,r,i,c,l){const a=t[0],d=t[1],u=t[2],n=e[0],h=e[1],R=e[2];for(let v=s;v<o;++v){const p=3*v,f=p+1,W=p+2,x=i*p,$=r[x],O=r[x+1],y=r[x+2],g=i*f,_=i*W,m=r[g]-$,b=r[g+1]-O,D=r[g+2]-y,w=r[_]-$,L=r[_+1]-O,P=r[_+2]-y,j=h*P-L*R,A=R*w-P*n,H=n*L-w*h,M=m*j+b*A+D*H;if(Math.abs(M)<=he)continue;const F=a-$,N=d-O,S=u-y,T=F*j+N*A+S*H;if(M>0){if(T<0||T>M)continue}else if(T>0||T<M)continue;const C=N*D-b*S,B=S*m-D*F,E=F*b-m*N,I=n*C+h*B+R*E;if(M>0){if(I<0||T+I>M)continue}else if(I>0||T+I<M)continue;const V=(w*C+L*B+P*E)/M;V>=0&&l(V,v,c?fe(m,b,D,w,L,P,K):null)}}function je(t,e,s,o,r,i,c,l,a,d,u){const n=t[0],h=t[1],R=t[2],v=e[0],p=e[1],f=e[2],{normalRequired:W}=d;for(let x=s;x<o;++x){const $=l[x],O=3*$,y=c*r[O];let g=i[y],_=i[y+1],m=i[y+2];const b=c*r[O+1];let D=i[b],w=i[b+1],L=i[b+2];const P=c*r[O+2];let j=i[P],A=i[P+1],H=i[P+2];a!=null&&([g,_,m]=a.applyToVertex(g,_,m,x),[D,w,L]=a.applyToVertex(D,w,L,x),[j,A,H]=a.applyToVertex(j,A,H,x));const M=D-g,F=w-_,N=L-m,S=j-g,T=A-_,C=H-m,B=p*C-T*f,E=f*S-C*v,I=v*T-S*p,V=M*B+F*E+N*I;if(Math.abs(V)<=he)continue;const G=n-g,te=h-_,se=R-m,J=G*B+te*E+se*I;if(V>0){if(J<0||J>V)continue}else if(J>0||J<V)continue;const ie=te*N-F*se,oe=se*M-N*G,ne=G*F-M*te,X=v*ie+p*oe+f*ne;if(V>0){if(X<0||J+X>V)continue}else if(X>0||J+X<V)continue;const ae=(S*ie+T*oe+C*ne)/V;ae>=0&&u(ae,$,W?fe(M,F,N,S,T,C,K):null)}}function de(t,e,s,o,r,i,c,l,a,d){const u=e,n=Je,h=Math.abs(u[0]),R=Math.abs(u[1]),v=Math.abs(u[2]),p=h>=R?h>=v?0:2:R>=v?1:2,f=p,W=u[f]<0?2:1,x=(p+W)%3,$=(p+(3-W))%3,O=u[x]/u[f],y=u[$]/u[f],g=1/u[f],_=Ae,m=Be,b=Ee,{normalRequired:D}=a;for(let w=s;w<o;++w){const L=3*w,P=c*r[L];Q(n[0],i[P+0],i[P+1],i[P+2]);const j=c*r[L+1];Q(n[1],i[j+0],i[j+1],i[j+2]);const A=c*r[L+2];Q(n[2],i[A+0],i[A+1],i[A+2]),l&&(re(n[0],l.applyToVertex(n[0][0],n[0][1],n[0][2],w)),re(n[1],l.applyToVertex(n[1][0],n[1][1],n[1][2],w)),re(n[2],l.applyToVertex(n[2][0],n[2][1],n[2][2],w))),U(_,n[0],t),U(m,n[1],t),U(b,n[2],t);const H=_[x]-O*_[f],M=_[$]-y*_[f],F=m[x]-O*m[f],N=m[$]-y*m[f],S=b[x]-O*b[f],T=b[$]-y*b[f],C=S*N-T*F,B=H*T-M*S,E=F*M-N*H;if((C<0||B<0||E<0)&&(C>0||B>0||E>0))continue;const I=C+B+E;if(I===0)continue;const V=C*(g*_[f])+B*(g*m[f])+E*(g*b[f]);if(V*Math.sign(I)<0)continue;const G=V/I;G>=0&&d(G,w,D?We(n):null)}}const Ae=q(),Be=q(),Ee=q();function fe(t,e,s,o,r,i,c){return Q(Z,t,e,s),Q(ee,o,r,i),le(c,Z,ee),ce(c,c),c}function We(t){return U(Z,t[1],t[0]),U(ee,t[2],t[0]),le(K,Z,ee),ce(K,K),K}const Z=q(),ee=q();function He(t,e){return Q(e,1/t[0],1/t[1],1/t[2])}function Ue(t,e,s,o){return ke(t,e,s,o,1/0)}function ke(t,e,s,o,r){const i=(t[0]-o-e[0])*s[0],c=(t[3]+o-e[0])*s[0];let l=Math.min(i,c),a=Math.max(i,c);const d=(t[1]-o-e[1])*s[1],u=(t[4]+o-e[1])*s[1];if(a=Math.min(a,Math.max(d,u)),a<0||(l=Math.max(l,Math.min(d,u)),l>a))return!1;const n=(t[2]-o-e[2])*s[2],h=(t[5]+o-e[2])*s[2];return a=Math.min(a,Math.max(n,h)),!(a<0)&&(l=Math.max(l,Math.min(n,h)),!(l>a)&&l<r)}const Ge=1e3,he=1e-7,xe=q(),Je=[q(),q(),q()];class ut{constructor(e){this.layout=e}elementCount(e){return e.get("position").indices.length}write(e,s,o,r,i,c){return Oe(o,r,this.layout,e,s,i,c)}intersect(e,s,o,r,i,c,l){const a=this.layout.createView(e).getField("position",Ce);if(a==null)return;const d=U(Ke,c,i),u=0,n=a.count/3,h=r.options.normalRequired,R=(v,p,f)=>l(v,f,p);De(i,d,u,n,a.typedBuffer,a.typedBufferStride,h,R)}}const Ke=q();function dt(t){t.vertex.uniforms.add(new ye("nearFar",e=>e.camera.nearFar))}function Qe(t){t.vertex.code.add(z`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`)}function ft(t){Qe(t),t.vertex.code.add(z`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),t.vertex.code.add(z`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function ht(t,e){e.hasVertexColors?(t.attributes.add("color","vec4"),t.varyings.add("vColor","vec4"),t.vertex.code.add(z`void forwardVertexColor() { vColor = color; }`),t.vertex.code.add(z`
      void forwardNormalizedVertexColor() { vColor = color * ${z.float(1/255)}; }
    `)):t.vertex.code.add(z`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}class xt{constructor(e){this.screenLength=Me(e.screenLength),this.minWorldLength=e.minWorldLength??0,this.maxWorldLength=e.maxWorldLength??1/0}}function mt(t,e){const s=t.vertex;e.hasVerticalOffset?(Ye(s),e.hasScreenSizePerspective&&(t.include(Te),Ve(s),Re(t.vertex,e)),s.code.add(z`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${e.spherical?z`vec3 worldNormal = normalize(worldPos + localOrigin);`:z`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${e.hasScreenSizePerspective?z`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:z`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)):s.code.add(z`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}const Xe=we();function Ye(t){t.uniforms.add(new ze("verticalOffset",(e,s)=>{const{minWorldLength:o,maxWorldLength:r,screenLength:i}=e.verticalOffset,c=Math.tan(.5*s.camera.fovY)/(.5*s.camera.fullViewport[3]),l=s.camera.pixelRatio||1;return _e(Xe,i*l,c,o,r)}))}class vt extends Le{constructor(e,s){super(e,"bool",0,(o,r)=>o.setUniform1b(e,s(r)))}}export{lt as M,Ue as U,vt as a,rt as b,Ye as c,ct as d,xt as e,Ne as f,at as h,dt as i,Fe as l,mt as n,ft as o,ht as r,ut as s};
